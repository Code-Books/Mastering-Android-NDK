/*
 * Copyright (C) 2013 Sergey Kosarevsky (sk@linderdaum.com)
 * Copyright (C) 2013 Viktor Latypov (vl@linderdaum.com)
 * Based on Linderdaum Engine http://www.linderdaum.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must display the names 'Sergey Kosarevsky' and
 *    'Viktor Latypov'in the credits of the application, if such credits exist.
 *    The authors of this work must be notified via email (sk@linderdaum.com) in
 *    this case of redistribution.
 *
 * 3. Neither the name of copyright holders nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "TextRenderer.h"

#include "Bitmap.h"

//#include "ft_load.inl"
#if defined( __GNUC__ )
// make the gcc happy
const int clTextRenderer::UTF8_LINE_END;
const int clTextRenderer::UTF8_DECODE_ERROR;
#endif

#include "FileSystem.h"

#undef DO_NOT_USE_ENGINE

#ifdef _WIN32
#  include <windows.h>
#endif

#pragma region Initialization

/**
   One more dynamic linking wrapper for FreeType library

   Why on Earth such an excellent project does NOT provide autogenerated function prototypes for dynamic linking possibility ?
*/
typedef FT_Error ( *FT_Init_FreeType_func )( FT_Library* alibrary );
typedef FT_Error ( *FT_Done_FreeType_func )( FT_Library  library );

typedef FT_Error ( *FT_Activate_Size_func )( FT_Size  size );

typedef FT_Error ( *FT_New_Face_func )( FT_Library library, const char* filepathname, FT_Long face_index, FT_Face* aface );
typedef FT_Error ( *FT_New_Memory_Face_func )( FT_Library library, const FT_Byte* file_base, FT_Long file_size, FT_Long face_index, FT_Face* aface );

typedef void     ( *FT_Glyph_Get_CBox_func )( FT_Glyph glyph, FT_UInt bbox_mode, FT_BBox* acbox );
typedef FT_Error ( *FT_Get_Kerning_func )( FT_Face face, FT_UInt left_glyph, FT_UInt right_glyph, FT_UInt kern_mode, FT_Vector* akerning );

typedef FT_Error ( *FTC_Manager_New_func )( FT_Library library, FT_UInt max_faces, FT_UInt max_sizes, FT_ULong max_bytes, FTC_Face_Requester requester, FT_Pointer req_data, FTC_Manager* amanager );
typedef void     ( *FTC_Manager_Done_func )( FTC_Manager manager );

typedef FT_Error ( *FTC_ImageCache_New_func )( FTC_Manager manager, FTC_ImageCache* acache );
typedef FT_Error ( *FTC_ImageCache_Lookup_func )( FTC_ImageCache cache, FTC_ImageType type, FT_UInt gindex, FT_Glyph* aglyph, FTC_Node* anode );

typedef FT_Error ( *FTC_CMapCache_New_func )( FTC_Manager manager, FTC_CMapCache* acache );
typedef FT_UInt  ( *FTC_CMapCache_Lookup_func )( FTC_CMapCache cache, FTC_FaceID face_id, FT_Int cmap_index, FT_UInt32 char_code );

typedef void     ( *FTC_Node_Unref_func )( FTC_Node node, FTC_Manager manager );

typedef FT_Error ( *FTC_Manager_LookupFace_func )( FTC_Manager manager, FTC_FaceID face_id, FT_Face* aface );
typedef FT_Error ( *FTC_Manager_LookupSize_func )( FTC_Manager manager, FTC_Scaler scaler,  FT_Size* asize );

// Helpers fr direct char manipulation
typedef FT_Error ( *FT_Load_Char_func )( FT_Face face, FT_ULong char_code, FT_Int32 load_flags );
typedef FT_Error ( *FT_Done_Face_func )( FT_Face  face );

// New function for outlines
typedef void     ( *FT_Outline_Get_CBox_func )( const FT_Outline*  outline, FT_BBox* acbox );
typedef FT_Error ( *FT_Outline_Embolden_func )  ( FT_Outline*  outline, FT_Pos strength );
typedef FT_Error ( *FT_Outline_EmboldenXY_func )( FT_Outline*  outline, FT_Pos xstrength, FT_Pos ystrength );
typedef void     ( *FT_Outline_Reverse_func )( FT_Outline*  outline );

FT_Outline_Get_CBox_func FT_Outline_Get_CBoxPTR;
FT_Outline_Embolden_func FT_Outline_EmboldenPTR;
FT_Outline_EmboldenXY_func FT_Outline_EmboldenXYPTR;
FT_Outline_Reverse_func FT_Outline_ReversePTR;

//

FT_Init_FreeType_func FT_Init_FreeTypePTR;

FT_Activate_Size_func FT_Activate_SizePTR;
FT_Done_FreeType_func FT_Done_FreeTypePTR;

FT_New_Face_func FT_New_FacePTR;
FT_New_Memory_Face_func FT_New_Memory_FacePTR;

FT_Glyph_Get_CBox_func FT_Glyph_Get_CBoxPTR;
FT_Get_Kerning_func FT_Get_KerningPTR;

FTC_Manager_New_func FTC_Manager_NewPTR;
FTC_Manager_Done_func FTC_Manager_DonePTR;

FTC_ImageCache_New_func FTC_ImageCache_NewPTR;
FTC_ImageCache_Lookup_func FTC_ImageCache_LookupPTR;

FTC_CMapCache_New_func FTC_CMapCache_NewPTR;
FTC_CMapCache_Lookup_func FTC_CMapCache_LookupPTR;

FTC_Node_Unref_func FTC_Node_UnrefPTR;

FTC_Manager_LookupFace_func FTC_Manager_LookupFacePTR;
FTC_Manager_LookupSize_func FTC_Manager_LookupSizePTR;

//
FT_Load_Char_func FT_Load_CharPTR;
FT_Done_Face_func FT_Done_FacePTR;

// HMODULE for Windows
void* hFTDll = NULL;

/// Number of initializations for multiple instances of clTextRenderer
int FTLoadCount = 0;

#undef FT_STATIC_LINK

#if defined(ANDROID) || defined(__APPLE__)
#  define FT_STATIC_LINK
#endif

#if defined(FT_STATIC_LINK)
extern "C"
{
	FT_Error FT_Init_FreeType( FT_Library* alibrary );
	FT_Error FT_Done_FreeType( FT_Library  library );
	FT_Error FT_Activate_Size( FT_Size  size );
	FT_Error FT_New_Face( FT_Library library, const char* filepathname, FT_Long face_index, FT_Face* aface );
	FT_Error FT_New_Memory_Face( FT_Library library, const FT_Byte* file_base, FT_Long file_size, FT_Long face_index, FT_Face* aface );
	void     FT_Glyph_Get_CBox( FT_Glyph glyph, FT_UInt bbox_mode, FT_BBox* acbox );
	FT_Error FT_Get_Kerning( FT_Face face, FT_UInt left_glyph, FT_UInt right_glyph, FT_UInt kern_mode, FT_Vector* akerning );
	FT_Error FTC_Manager_New( FT_Library library, FT_UInt max_faces, FT_UInt max_sizes, FT_ULong max_bytes, FTC_Face_Requester requester, FT_Pointer req_data, FTC_Manager* amanager );
	void     FTC_Manager_Done( FTC_Manager manager );
	FT_Error FTC_ImageCache_New( FTC_Manager manager, FTC_ImageCache* acache );
	FT_Error FTC_ImageCache_Lookup( FTC_ImageCache cache, FTC_ImageType type, FT_UInt gindex, FT_Glyph* aglyph, FTC_Node* anode );
	FT_Error FTC_CMapCache_New( FTC_Manager manager, FTC_CMapCache* acache );
	FT_UInt  FTC_CMapCache_Lookup( FTC_CMapCache cache, FTC_FaceID face_id, FT_Int cmap_index, FT_UInt32 char_code );
	void     FTC_Node_Unref( FTC_Node node, FTC_Manager manager );
	FT_Error FTC_Manager_LookupFace( FTC_Manager manager, FTC_FaceID face_id, FT_Face* aface );
	FT_Error FTC_Manager_LookupSize( FTC_Manager manager, FTC_Scaler scaler,  FT_Size* asize );
}
#endif // Static link

bool LoadFT()
{
	if ( hFTDll != NULL ) { return true; }

#if defined(_WIN32)

#define LOAD_FT_FUNC(Func_) \
   Func_##PTR = (Func_##_func) GetProcAddress( (HMODULE)hFTDll, #Func_ ); \
   if(! Func_##PTR) { /*printf("Cannot load %s function !\n", #Func_ );*/ return false; }

	std::string LibName;

#ifdef _WIN64
	LibName = "libfreetype-6-64.dll";
#else
	LibName = "libfreetype-6-32.dll";
#endif

	*( ( HMODULE* )&hFTDll ) = LoadLibrary( LibName.c_str() );

	if ( hFTDll == INVALID_HANDLE_VALUE )
	{
//		printf("Cannot load FreeType dll !\n");
		return false;
	}

#else

#    define LOAD_FT_FUNC(Func_) Func_##PTR = &Func_;

#endif

	LOAD_FT_FUNC( FT_Init_FreeType )

	LOAD_FT_FUNC( FT_Activate_Size )
	LOAD_FT_FUNC( FT_Done_FreeType )

	LOAD_FT_FUNC( FT_New_Face )
	LOAD_FT_FUNC( FT_New_Memory_Face )

	LOAD_FT_FUNC( FT_Glyph_Get_CBox )
	LOAD_FT_FUNC( FT_Get_Kerning )

	LOAD_FT_FUNC( FTC_Manager_New )
	LOAD_FT_FUNC( FTC_Manager_Done )

	LOAD_FT_FUNC( FTC_ImageCache_New )
	LOAD_FT_FUNC( FTC_ImageCache_Lookup )

	LOAD_FT_FUNC( FTC_CMapCache_New )
	LOAD_FT_FUNC( FTC_CMapCache_Lookup )

	LOAD_FT_FUNC( FTC_Node_Unref )

	LOAD_FT_FUNC( FTC_Manager_LookupFace )
	LOAD_FT_FUNC( FTC_Manager_LookupSize )

	//LOAD_FT_FUNC( FT_Outline_Get_CBox )
	//LOAD_FT_FUNC( FT_Outline_Embolden )
	//LOAD_FT_FUNC( FT_Outline_EmboldenXY )
	//LOAD_FT_FUNC( FT_Outline_Reverse )
	//LOAD_FT_FUNC( FT_Load_Char )
	//LOAD_FT_FUNC( FT_Done_Face )

#undef LOAD_FT_FUNC

	FTLoadCount++;

//	printf("Loaded FT\n");

	return true;
}

void UnloadFT()
{
	if ( hFTDll == NULL ) { return; }

	FTLoadCount--;

	if ( FTLoadCount > 0 ) { return; }

#if defined(_WIN32)
	FreeLibrary( ( HMODULE )hFTDll );
#endif
	hFTDll = NULL;
}


#include "Bitmap.h"
#include <stdio.h>

#include <fstream>

clTextRenderer::clTextRenderer()
	: FInitialized( false )
	, FLibrary( NULL )
	, FManager( NULL )
	, FImageCache( NULL )
	, FCMapCache( NULL )
{
	InitFreeType();
	FMaskMode = false;
}

bool clTextRenderer::DecodeUTF8( const char* InStr )
{
	FIndex = 0;
	FBuffer = InStr;
	FLength = ( int )strlen( InStr );

	FString.clear();

	int R = DecodeNextUTF8Char();

	while ( ( R != UTF8_LINE_END ) && ( R != UTF8_DECODE_ERROR ) )
	{
		sFTChar Ch;
		Ch.FChar    = R;
		FString.push_back( Ch );
		R = DecodeNextUTF8Char();
	}

	return ( R != UTF8_DECODE_ERROR );
}

/*
    strict UTF-8 decoder for continuations not more than 4 bytes

    Code     | Cont |  Min  |    Max
    ==================================
    0xxxxxxx |   0  |     0 |     127
    110xxxxx |   1  |   128 |    2047
    1110xxxx |   2  |  2048 |   65535 \ {55296..57343}
    11110xxx |   3  | 65536 | 1114111
*/

int clTextRenderer::DecodeNextUTF8Char()
{
	// the first byte of the character and the result
	int c, r;

	if ( FIndex >= FLength ) { return FIndex == FLength ? UTF8_LINE_END : UTF8_DECODE_ERROR; }

	c = NextUTF8();

	// Zero continuation (0 to 127)
	if ( ( c & 0x80 ) == 0 ) { return c; }

	// First contination (128 to 2047)
	if ( ( c & 0xE0 ) == 0xC0 )
	{
		int c1 = ContUTF8();

		if ( c1 < 0 ) { return UTF8_DECODE_ERROR; }

		r = ( ( c & 0x1F ) << 6 ) | c1;
		return r >= 128 ? r : UTF8_DECODE_ERROR;
	}

	// Second continuation (2048 to 55295 and 57344 to 65535)
	if ( ( c & 0xF0 ) == 0xE0 )
	{
		int c1 = ContUTF8();
		int c2 = ContUTF8();

		if ( c1 < 0 || c2 < 0 ) { return UTF8_DECODE_ERROR; }

		r = ( ( c & 0x0F ) << 12 ) | ( c1 << 6 ) | c2;
		return r >= 2048 && ( r < 55296 || r > 57343 ) ? r : UTF8_DECODE_ERROR;
	}

	// Third continuation (65536 to 1114111)
	if ( ( c & 0xF8 ) == 0xF0 )
	{
		int c1 = ContUTF8();
		int c2 = ContUTF8();
		int c3 = ContUTF8();

		if ( c1 < 0 || c2 < 0 || c3 < 0 ) { return UTF8_DECODE_ERROR; }

		r = ( ( c & 0x0F ) << 18 ) | ( c1 << 12 ) | ( c2 << 6 ) | c3;
		return r >= 65536 && r <= 1114111 ? r : UTF8_DECODE_ERROR;
	}

	return UTF8_DECODE_ERROR;
}

void clTextRenderer::InitFreeType()
{
	FInitialized = LoadFT();

	if ( FInitialized )
	{
		FInitialized = false;

		if ( FT_Init_FreeTypePTR( &FLibrary ) != 0 ) { return; }

		if ( FTC_Manager_NewPTR( FLibrary, 0, 0, 0, FreeType_Face_Requester, this, &FManager ) != 0 ) { return; }

		if ( FTC_ImageCache_NewPTR( FManager, &FImageCache ) != 0 ) { return; }

		if ( FTC_CMapCache_NewPTR( FManager, &FCMapCache ) != 0 ) { return; }

		FInitialized = true;
	}
}

void clTextRenderer::StopFreeType()
{
	FreeString();

	// deallocate font handles and release font buffers
	for ( std::map<std::string, void*>::iterator p = FAllocatedFonts.begin(); p != FAllocatedFonts.end() ; p++ )
	{
		// ? FT_FreeFace (FFontFaceHandles[p->first]);
		delete[] ( char* )( p->second );
	}

	FFontFaces.clear();

	if ( FManager ) { FTC_Manager_DonePTR( FManager ); }

	if ( FLibrary ) { FT_Done_FreeTypePTR( FLibrary ); }
}

#pragma endregion
// end of init code

//#define DO_NOT_USE_ENGINE

extern clPtr<clFileSystem> g_FS;

FT_Error clTextRenderer::LoadFontFile( const std::string& FileName )
{
	if ( !FInitialized ) { return -1; }

	if ( FAllocatedFonts.count( FileName ) > 0 ) { return 0; }

#if 0
	std::ifstream InFile( FileName.c_str(), std::ios::in | std::ifstream::binary );
	std::vector<char> DataIn( ( std::istreambuf_iterator<char>( InFile ) ), std::istreambuf_iterator<char>() );

	int DataSize = ( int )DataIn.size();
	char* Data = new char[DataSize];

	memcpy( Data, &DataIn[0], DataSize );
#else
	clPtr<clBlob> DataBlob = LoadFileAsBlob( g_FS, FileName );
	int DataSize = DataBlob->GetSize();

	char* Data = new char[DataSize];
	memcpy( Data, DataBlob->GetData(), DataSize );
#endif

	FT_Face TheFace;

	// 0 is the face index
	FT_Error Result = FT_New_Memory_FacePTR( FLibrary, ( FT_Byte* )Data, ( FT_Long )DataSize, 0, &TheFace );

	if ( Result == 0 )
	{
		FFontFaceHandles[FileName] = TheFace;
		FAllocatedFonts[FileName] = ( void* )Data;

		FFontFaces.push_back( FileName );
	}

	return Result;
}

FT_Error clTextRenderer::FreeType_Face_Requester( FTC_FaceID FaceID, FT_Library Library, FT_Pointer RequestData, FT_Face* TheFace )
{
	( void )Library;

#if defined(_WIN64) || defined(__x86_64__)
	long long int Idx = ( long long int )FaceID;
	int FaceIdx = ( int )( Idx & 0xFF );
#else
	int FaceIdx = reinterpret_cast< int >( FaceID );
#endif

	if ( FaceIdx < 0 ) { return 1; }

	clTextRenderer* This = ( clTextRenderer* )RequestData;

	std::string FileName = This->FFontFaces[FaceIdx];

	FT_Error LoadResult = This->LoadFontFile( FileName );

	*TheFace = ( LoadResult == 0 ) ? This->FFontFaceHandles[FileName] : NULL;

	return LoadResult;
}

void clTextRenderer::FreeString()
{
	for ( size_t i = 0 ; i < FString.size() ; i++ )
	{
		if ( FString[i].FCacheNode != NULL )
		{
			FTC_Node_UnrefPTR( FString[i].FCacheNode, FManager );
			FString[i].FCacheNode = NULL;
		}
	}

	FString.clear();
}

inline void* IntToID( int FontID )
{
#if defined(_WIN64) || defined (__x86_64__)
	long long int Idx = FontID;
#else
	int Idx = FontID;
#endif
	FTC_FaceID ID = reinterpret_cast<void*>( Idx );

	return ID;
}

FT_UInt clTextRenderer::GetCharIndex( int FontID, FT_UInt Char )
{
	/// Default charmap causes severe problems on Mac OS. There is another default encoding
	return FTC_CMapCache_LookupPTR( FCMapCache, IntToID( FontID ), -1 /* use default cmap */, Char );
}

FT_Glyph clTextRenderer::GetGlyph( int FontID, int Height, FT_UInt Char, FT_UInt LoadFlags, FTC_Node* CNode )
{
	FT_UInt Index = GetCharIndex( FontID, Char );

	FTC_ImageTypeRec ImageType;

	ImageType.face_id = IntToID( FontID );
	ImageType.height = Height;
	ImageType.width = 0;
	ImageType.flags = LoadFlags;

	FT_Glyph Glyph;

	if ( FTC_ImageCache_LookupPTR( FImageCache, &ImageType, Index, &Glyph, CNode ) != 0 ) { return NULL; }

	return Glyph;
}

void clTextRenderer::SetAdvance( sFTChar& Char )
{
	Char.FAdvance = Char.FWidth = 0;

	if ( !Char.FGlyph ) { return; }

	Char.FAdvance = Char.FGlyph->advance.x >> 10;

	FT_BBox bbox;
	FT_Glyph_Get_CBoxPTR( Char.FGlyph, FT_GLYPH_BBOX_GRIDFIT, &bbox );
	Char.FWidth = bbox.xMax;

	// use advance as the width for empty glyphs (like space)
	if ( Char.FWidth == 0 && Char.FAdvance != 0 ) { Char.FWidth = Char.FAdvance; }
}

void clTextRenderer::Kern( sFTChar& Left, const sFTChar& Right )
{
	if ( Left.FIndex == -1 || Right.FIndex == -1 ) { return; }

	FT_Vector Delta;
	FT_Get_KerningPTR( FFace, Left.FIndex, Right.FIndex, FT_KERNING_DEFAULT, &Delta );

	Left.FAdvance += Delta.x;
}

FT_Face clTextRenderer::GetSizedFace( int FontID, int Height )
{
	FTC_ScalerRec Scaler;

	Scaler.face_id = IntToID( FontID );
	Scaler.height = Height;
	Scaler.width = 0;
	Scaler.pixel = 1;

	FT_Size SizedFont;

	if ( FTC_Manager_LookupSizePTR( FManager, &Scaler, &SizedFont ) != 0 ) { return NULL; }

	if ( FT_Activate_SizePTR( SizedFont ) != 0 ) { return NULL; }

	return SizedFont->face;
}

int clTextRenderer::GetFontHandle( const std::string& FileName )
{
	if ( LoadFontFile( FileName ) != 0 )
	{
		return -1;
	}

	for ( int i = 0 ; i != ( int )FFontFaces.size() ; i++ )
	{
		if ( FFontFaces[i] == FileName ) { return i; }
	}

	return -1;
}

bool clTextRenderer::LoadStringWithFont( const std::string& S, int ID, int Height )
{
	if ( ID < 0 ) { return false; }

	// 1. Get the font face
	FFace = GetSizedFace( ID, Height );

	if ( FFace == NULL ) { return false; }

	bool UseKerning = FT_HAS_KERNING( FFace ) != 0;

	// 2. Decode utf8 string
	DecodeUTF8( S.c_str() );

	// 3. Calculate character sizes
	for ( size_t i = 0, count = FString.size(); i != count; i++ )
	{
		sFTChar& Char = FString[i];
		FT_UInt ch = Char.FChar;

		Char.FIndex = ( ch != '\r' && ch != '\n' ) ? GetCharIndex( ID, ch ) : -1;
		Char.FGlyph = ( Char.FIndex != -1 ) ? GetGlyph( ID, Height, ch, FT_LOAD_RENDER, &Char.FCacheNode ) : NULL;

		if ( !Char.FGlyph || Char.FIndex == -1 ) { continue; }

		SetAdvance( Char );

		if ( i > 0 && UseKerning ) { Kern( FString[i - 1], Char ); }
	}

	return true;
}

void clTextRenderer::CalculateLineParameters( int* Width, int* MinY, int* MaxY, int* BaseLine ) const
{
	int StrMinY = -1000;
	int StrMaxY = -1000;

	if ( FString.empty() )
	{
		StrMinY = 0;
		StrMaxY = 0;
	}

	int SizeX = 0;

	for ( size_t i = 0 ; i != FString.size(); i++ )
	{
		if ( FString[i].FGlyph == NULL ) { continue; }

		FT_BitmapGlyph BmpGlyph = ( FT_BitmapGlyph )FString[i].FGlyph;

		SizeX += FString[i].FAdvance;

		int Y = BmpGlyph->top;
		int H = BmpGlyph->bitmap.rows;

		if ( Y     > StrMinY ) { StrMinY = Y; }

		if ( H - Y > StrMaxY ) { StrMaxY = H - Y; }
	}

	if ( Width    ) { *Width = ( SizeX >> 6 ); }

	if ( BaseLine ) { *BaseLine = StrMaxY; }

	if ( MinY     ) { *MinY = StrMinY; }

	if ( MaxY     ) { *MaxY = StrMaxY; }
}

void clTextRenderer::RenderLineOnBitmap(
   const std::string& TextString, int FontID, int FontHeight, int StartX, int Y, const ivec4& Color, bool LeftToRight, const clPtr<clBitmap>& Out
)
{
	LoadStringWithFont( TextString, FontID, FontHeight );

	int x = StartX << 6;

	for ( size_t j = 0 ; j != FString.size(); j++ )
	{
		if ( FString[j].FGlyph != 0 )
		{
			FT_BitmapGlyph BmpGlyph = ( FT_BitmapGlyph ) FString[j].FGlyph;

			int in_x = ( x >> 6 ) + ( ( LeftToRight ? 1 : -1 ) * BmpGlyph->left );

			if ( !LeftToRight )
			{
				in_x += BmpGlyph->bitmap.width;
				in_x = StartX + ( StartX - in_x );
			}

			DrawGlyphOnBitmap( Out, &BmpGlyph->bitmap, in_x, Y - BmpGlyph->top /*- 5*/, Color );
		}

		x += FString[j].FAdvance;
	}
}

/// Create appropriate bitmap and render text line using specified font
clPtr<clBitmap> clTextRenderer::RenderTextWithFont(
   const std::string& TextString, int FontID, int FontHeight, const ivec4& Color, bool LeftToRight
)
{
	if ( !LoadStringWithFont( TextString, FontID, FontHeight ) ) { return nullptr; }

	int W, Y;
	int MinY, MaxY;
	CalculateLineParameters( &W, &MinY, &MaxY, &Y );
	int H2 = MaxY + MinY;

	int Add = 0; //10;

	clPtr<clBitmap> Result = make_intrusive<clBitmap>( W, H2 + Add * 2, L_BITMAP_BGRA8 );
	Result->Clear();

	RenderLineOnBitmap( TextString, FontID, FontHeight, LeftToRight ? 0 : W - 1, MinY + Add, Color, LeftToRight, Result );

	return Result;
}

/// Multiply each component of the int-encoded color by Mult
inline unsigned int MultColor( unsigned int Color, unsigned int Mult )
{
//	return ( ( unsigned int )Mult << 24 ) | Color;
	return
	   ( ( ( ( Color      ) & 0xFF ) * Mult >> 8 )      ) +
	   ( ( ( ( Color >>  8 ) & 0xFF ) * Mult >> 8 ) <<  8 ) +
	   ( ( ( ( Color >> 16 ) & 0xFF ) * Mult >> 8 ) << 16 );
}

/// c1 * M + (1 - M) * c2
inline LVector4i BlendColors( const LVector4i& C1, const LVector4i& C2, unsigned int F )
{
	int r = ( ( C1.x ) * F >> 8 ) + ( ( C2.x ) * ( 255 - F ) >> 8 );
	int g = ( ( C1.y ) * F >> 8 ) + ( ( C2.y ) * ( 255 - F ) >> 8 );
	int b = ( ( C1.z ) * F >> 8 ) + ( ( C2.z ) * ( 255 - F ) >> 8 );

	return LVector4i( r, g, b, 255 );
}

void clTextRenderer::DrawGlyphOnBitmap( const clPtr<clBitmap>& Out, FT_Bitmap* Bitmap, int X0, int Y0, const ivec4& Color ) const
{
	int W = Out->GetWidth();
	int Width = W - X0;

	if ( Width > Bitmap->width ) { Width = Bitmap->width; }

	for ( int Y = Y0 ; Y < Y0 + Bitmap->rows ; ++Y )
	{
		unsigned char* Src = Bitmap->buffer + ( Y - Y0 ) * Bitmap->pitch;

		if ( FMaskMode )
		{
			for ( int X = X0 + 0 ; X < X0 + Width ; X++ )
			{
				int Int = *Src++;
				int OutMaskCol = ( Int & 0xFF );

				Out->SetPixel( X, Y, LVector4i( OutMaskCol, OutMaskCol, OutMaskCol, 255 ) );
			}
		}
		else
		{
			for ( int X = X0 + 0 ; X < X0 + Width ; X++ )
			{
				unsigned int Int = *Src++;

				ivec4 Col = BlendColors( Color, Out->GetPixel( X, Y ), ( Int & 0xFF ) );

				if ( Int > 0 )
				{
					Col.w = Int;
					Out->SetPixel( X, Y, Col );
				}
			}
		}
	}
}

clTextRenderer* clTextRenderer::Instance()
{
	static clTextRenderer Instance;

	return &Instance;
}
